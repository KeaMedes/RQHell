/*
 * This Java source file was generated by the Gradle 'init' task.
 */
import net.fec.openrq.EncodingPacket;
import net.fec.openrq.OpenRQ;
import net.fec.openrq.SymbolType;
import net.fec.openrq.encoder.DataEncoder;
import net.fec.openrq.encoder.SourceBlockEncoder;
import net.fec.openrq.parameters.FECParameters;
import net.fec.openrq.util.rq.SystematicIndices;

import java.io.*;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.SocketChannel;
import java.nio.file.Path;
import java.util.logging.Logger;

public class Client {
    private Logger LOG = Logger.getLogger("Client");
    private Path mPath = null;
    private ShareFEC mShareFEC;
    private OutputStream mSocketOs = null;
    private double mLostRate;

    public Client() {}

    public void setFile(Path path) {
        mPath = path;
    }

    public void sendFile(Path path) {
        Path targetPath = null;
        if (path != null) {
            targetPath = path;
        } else if (mPath != null) {
            targetPath = mPath;
        } else {
            LOG.severe("No file to be sent");
            return;
        }
        File f = new File(targetPath.toString());

        LOG.info("Calculate the FECParameters");
        long fSize = f.length();
        mShareFEC = new ShareFEC();
        mShareFEC.setFileSize(fSize);
        FECParameters fecParameters = mShareFEC.getParameters();
        ByteBuffer buffer = fecParameters.asBuffer();
        System.out.println(buffer.limit());
        System.out.println(mShareFEC.getPacketSize());
        int symbolSize = fecParameters.symbolSize();
        int numSourceBlocks = fecParameters.numberOfSourceBlocks();
        LOG.info(String.format("Final FECParameters: file size: %d, symbol size: %d, number of source blocks: %d", fSize, symbolSize, numSourceBlocks));

        LOG.info("Loading file to memory");
        ByteBuffer byteBuffer;
        try {
            FileInputStream fin = new FileInputStream(f);
            FileChannel fileChannel = fin.getChannel();
            byteBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fSize);
        } catch (FileNotFoundException e) {
            LOG.severe("File not found");
            return;
        } catch (IOException e) {
            LOG.severe("Error while mapping the file into memory");
            return;
        }
        LOG.info("Success in mapping the file inot memory");

        LOG.info("Send the fecParameters to the server");
        ByteBuffer fecBuffer = fecParameters.asBuffer();
        try {
            mSocketOs.write(fecBuffer.array());
        } catch (IOException e) {
            e.printStackTrace();
        }

        DataEncoder encoder = OpenRQ.newEncoder(byteBuffer.array(), fecParameters);
        for (SourceBlockEncoder sourceBlockEncoder : encoder.sourceBlockIterable()) {
            int numberOfSourceSymbols = sourceBlockEncoder.numberOfSourceSymbols();
            for (EncodingPacket pac : sourceBlockEncoder.sourcePacketsIterable()) {
                if (!sendPacket(pac)) {
                    System.out.println("Fail to send source data packet");
                    return;
                }
            }
            int nr = numberOfRepairSymbols();
            long startTime = System.currentTimeMillis();
            for (EncodingPacket pac : sourceBlockEncoder.repairPacketsIterable(nr)) {
                if (!sendPacket(pac)) {
                    System.out.println("Fail to send repair packet");
                    return;
                }
            }
            long endTime = System.currentTimeMillis();
            System.out.println(String.format("used time for %d repair symbols in %d source symbols: %d",
                    endTime - startTime, nr, numberOfSourceSymbols));
        }
    }

    private int numberOfRepairSymbols() {
        return 10;
    }

    private boolean sendPacket(EncodingPacket pac) {
        int numberOfSourceSymbols = pac.numberOfSymbols();
        int encodingSymbolId = pac.encodingSymbolID();
        int fecId = pac.fecPayloadID();
        byte[] data = pac.asArray();
        int size = data.length;
        System.out.println(String.format("numberOfSourceSymbols: %d, encodingId: %d, fecId: %d, size: %d",
                numberOfSourceSymbols, encodingSymbolId, fecId, size));
        if (mSocketOs == null) {
            System.out.println("Output Stream is not established");
            return false;
        }
        try {
            mSocketOs.write(pac.asArray());
            return true;
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
    }

    public void establish(String hostAddr, int hostPort) {
        try {
            Socket socket = new Socket(hostAddr, hostPort);
            mSocketOs = socket.getOutputStream();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public double getLostRate() {
        return mLostRate;
    }

    public void setLostRate(double mLostRate) {
        this.mLostRate = mLostRate;
    }
}
