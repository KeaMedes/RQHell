/*
 * This Java source file was generated by the Gradle 'init' task.
 */
import net.fec.openrq.EncodingPacket;
import net.fec.openrq.OpenRQ;
import net.fec.openrq.SymbolType;
import net.fec.openrq.encoder.DataEncoder;
import net.fec.openrq.encoder.SourceBlockEncoder;
import net.fec.openrq.parameters.FECParameters;
import net.fec.openrq.util.rq.SystematicIndices;

import java.io.*;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.SocketChannel;
import java.nio.file.Path;
import java.util.logging.Logger;

public class Client {
    private Logger LOG = Logger.getLogger("Client");
    private Path mPath = null;
    private ShareFEC mShareFEC;
    private OutputStream mSocketOs = null;
    private InputStream mSocketIs = null;
    private double mLostRate;

    public Client() {}

    public void setFile(Path path) {
        mPath = path;
    }

    public void sendFile(Path path) {
        Path targetPath = null;
        if (path != null) {
            targetPath = path;
        } else if (mPath != null) {
            targetPath = mPath;
        } else {
            LOG.severe("No file to be sent");
            return;
        }
        File f = new File(targetPath.toString());

        LOG.info("Calculate the FECParameters");
        long fSize = f.length();
        mShareFEC = new ShareFEC();
        mShareFEC.setFileSize(fSize);
        FECParameters fecParameters = mShareFEC.getParameters();
        int symbolSize = fecParameters.symbolSize();
        int numSourceBlocks = fecParameters.numberOfSourceBlocks();
        LOG.info(String.format("Final FECParameters: file size: %d, symbol size: %d, number of source blocks: %d", fSize, symbolSize, numSourceBlocks));

        LOG.info("Loading file to memory");
        ByteBuffer byteBuffer;
        try {
            FileInputStream fin = new FileInputStream(f);
            FileChannel fileChannel = fin.getChannel();
            byte[] array = new byte[(int)f.length()];
            byteBuffer = ByteBuffer.wrap(array);
            fileChannel.read(byteBuffer);
        } catch (FileNotFoundException e) {
            LOG.severe("File not found");
            return;
        } catch (IOException e) {
            LOG.severe("Error while mapping the file into memory");
            return;
        }
        LOG.info("Success in mapping the file inot memory");

        LOG.info("Send the fecParameters to the server");
        ByteBuffer fecBuffer = fecParameters.asBuffer();
        int state = 0;
        try {
            mSocketOs.write(fecBuffer.array());
            LOG.info("Wait for the response of the server");
            state = 1;
            // 2-bytes: OK
            byte[] buf = new byte[2];
            int bufLen = 0;
            while (true) {
                bufLen += mSocketIs.read(buf, bufLen, 2);
                if (bufLen == 2) {
                    LOG.info("Success reading from server the response");
                    break;
                } else {
                    LOG.info(String.format("Reading part of the server response, length: %d", bufLen));
                }
            }
            state = 2;
            String response = new String(buf);
            if ("OK".equals(response)) {
                LOG.info("Server has receive the fecParameters");
            } else {
                LOG.info("Server fail to receive the fecParameters");
                return;
            }
        } catch (IOException e) {
            if (state == 0) {
                LOG.severe("Fail to send the fecParameters to server");
            } else {
                LOG.severe("Fail to receive the response from the server");
            }
            return;
        }

        DataEncoder encoder = OpenRQ.newEncoder(byteBuffer.array(), fecParameters);
        long startTime = System.currentTimeMillis();
        for (SourceBlockEncoder sourceBlockEncoder : encoder.sourceBlockIterable()) {
            LOG.info(String.format("Sending block: %d", sourceBlockEncoder.sourceBlockNumber()));
            for (EncodingPacket pac : sourceBlockEncoder.sourcePacketsIterable()) {
                if (!sendPacket(pac)) {
                    return;
                }
            }
            int nr = numberOfRepairSymbols();
            for (EncodingPacket pac : sourceBlockEncoder.repairPacketsIterable(nr)) {
                if (!sendPacket(pac)) {
                    return;
                }
            }
        }
        long endTime = System.currentTimeMillis();
        LOG.info(String.format("Send the data with %d ms", endTime - startTime));
    }

    private int numberOfRepairSymbols() {
        return 10;
    }

    private boolean sendPacket(EncodingPacket pac) {
        try {
            mSocketOs.write(pac.asArray());
            return true;
        } catch (IOException e) {
            e.printStackTrace();
            LOG.severe(String.format("Fail to send packet: %d", pac.encodingSymbolID()));
            return false;
        }
    }

    public void establish(String hostAddr, int hostPort) {
        try {
            Socket socket = new Socket(hostAddr, hostPort);
            mSocketOs = socket.getOutputStream();
            mSocketIs = socket.getInputStream();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public double getLostRate() {
        return mLostRate;
    }

    public void setLostRate(double mLostRate) {
        this.mLostRate = mLostRate;
    }
}
