/*
 * This Java source file was generated by the Gradle 'init' task.
 */
import net.fec.openrq.EncodingPacket;
import net.fec.openrq.OpenRQ;
import net.fec.openrq.encoder.DataEncoder;
import net.fec.openrq.encoder.SourceBlockEncoder;
import net.fec.openrq.parameters.FECParameters;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.SocketChannel;
import java.nio.file.Path;

public class Client {
    public Client() {}

    public void sendFile(Path path) {
        File f = new File(path.toString());
        long fSize = f.length();
        FECParameters fecParameters = FECParameters.deriveParameters(fSize, 1024, 1024 * 10);
        int symbolSize = fecParameters.symbolSize();
        int numSourceBlocks = fecParameters.numberOfSourceBlocks();
        System.out.println(String.format("file size: %d, symbol size: %d, number of source blocks: %d", fSize, symbolSize, numSourceBlocks));

        FileInputStream fin = null;
        try {
            fin = new FileInputStream(f);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            return;
        }

        FileChannel fileChannel = fin.getChannel();
        ByteBuffer byteBuffer = ByteBuffer.allocate((int) fSize);
        try {
            if (fileChannel.read(byteBuffer) != fSize) {
                System.out.println("fail to read enough data");
                return;
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        DataEncoder encoder = OpenRQ.newEncoder(byteBuffer.array(), fecParameters);
        for (SourceBlockEncoder sourceBlockEncoder : encoder.sourceBlockIterable()) {
            int numberOfSourceSymbols = sourceBlockEncoder.numberOfSourceSymbols();
            System.out.println(String.format("number of source symbols: %d", numberOfSourceSymbols));
            long startTime = System.currentTimeMillis();
            for (EncodingPacket pac : sourceBlockEncoder.sourcePacketsIterable()) {
                sendPacket(pac);
            }
            long endTime = System.currentTimeMillis();
            System.out.println(String.format("usd time : %d", endTime - startTime));
            int nr = numberOfRepairSymbols();
            startTime = System.currentTimeMillis();
            for (EncodingPacket pac : sourceBlockEncoder.repairPacketsIterable(nr)) {
                sendPacket(pac);
            }
            endTime = System.currentTimeMillis();
            System.out.println(String.format("usd time : %d", endTime - startTime));
        }
    }

    private int numberOfRepairSymbols() {
        return 2;
    }

    private boolean sendPacket(EncodingPacket pac) {
        int numberOfSourceSymbols = pac.numberOfSymbols();
        int encodingSymbolId = pac.encodingSymbolID();
        int fecId = pac.fecPayloadID();
        byte[] data = pac.asArray();
        int size = data.length;
        System.out.println(String.format("numberOfSourceSymbols: %d, encodingId: %d, fecId: %d, size: %d",
                numberOfSourceSymbols, encodingSymbolId, fecId, size));
        return false;
    }

    public void establish(String hostAddr, int hostPort) {
        SocketChannel sChannel = null;
        try {
            sChannel = SocketChannel.open();
            sChannel.configureBlocking(false);
            if (!sChannel.connect(new InetSocketAddress(hostAddr, hostPort))) {
                while (!sChannel.finishConnect()) {
                    System.out.print(".");
                }
            }
            System.out.println();

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
